import com.google.gson.reflect.TypeToken;
import InvalidRequestException;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import AppUser;

import java.time.Duration;
import java.time.Instant;
import java.util.Base64;
import java.util.Base64.Decoder;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

import static GSON;
import static JwtConstants.INVALID_ACCESS_TOKEN_MESSAGE;
import static JwtConstants.INVALID_REFRESH_TOKEN_MESSAGE;
import static JwtConstants.INVALID_REQUEST;
import static JwtConstants.IS_ACCESS_TOKEN;

public class JwtTokenUtil {

    private static final Decoder DECODER = Base64.getUrlDecoder();

    //generate token for user
    public static String generateToken(final AppUser appUser,
                                       final long validitySeconds,
                                       final boolean isAccessToken,
                                       final String secretKey) {
        final Map<String, Object> claims = new HashMap<>();
        claims.put("userId", appUser.getId());
        claims.put(IS_ACCESS_TOKEN, isAccessToken);
        return doGenerateToken(claims, appUser.getUsername(), validitySeconds, secretKey);
    }

    // validate token
    public static boolean validateAccessToken(final String token,
                                              final String secretKey) {
        final var isAccessToken = (boolean) getDataByKeyFromToken(token, IS_ACCESS_TOKEN, secretKey);
        return !isTokenExpired(token, secretKey) && isAccessToken;
    }

    // validate refresh token
    public static boolean validateRefreshToken(final String refreshToken, final String secretKey) {
        final var isAccessToken = (boolean) getDataByKeyFromToken(refreshToken, IS_ACCESS_TOKEN, secretKey);
        return !isTokenExpired(refreshToken, secretKey) && !isAccessToken;
    }

    public static String decodeUsernameFromAccessToken(final String accessToken) {
        return decodeUsernameFromToken(accessToken, INVALID_ACCESS_TOKEN_MESSAGE);
    }

    public static String decodeUsernameFromRefreshToken(final String refreshToken) {
        return decodeUsernameFromToken(refreshToken, INVALID_REFRESH_TOKEN_MESSAGE);
    }

    private static String decodeUsernameFromToken(final String token, final String errorMessage) {
        try {
            final var tokenPaths = token.split("\\.");
            final var payload = new String(DECODER.decode(tokenPaths[1]));
            final var typeOfMap = new TypeToken<Map<String, Object>>() {
            }.getType();
            final Map<String, Object> jsonPayload = GSON.fromJson(payload, typeOfMap);
            return jsonPayload.get("sub").toString();
        } catch (final Exception exception) {
            throw new InvalidRequestException(INVALID_REQUEST, errorMessage + token);
        }
    }

    //retrieve data by key from jwt token
    private static Object getDataByKeyFromToken(final String token,
                                                final String key,
                                                final String secretKey) {
        final var claims = getAllClaimsFromToken(token, secretKey);
        return claims.get(key);
    }

    //retrieve expiration date from jwt token
    public static Date getExpirationDateFromToken(final String token,
                                                  final String secretKey) {
        return getClaimFromToken(token, secretKey, Claims::getExpiration);
    }

    private static <T> T getClaimFromToken(final String token,
                                           final String secretKey,
                                           final Function<Claims, T> claimsResolver) {
        final var claims = getAllClaimsFromToken(token, secretKey);
        return claimsResolver.apply(claims);
    }

    //for retrieving any information from token we will need the secret key
    private static Claims getAllClaimsFromToken(final String token,
                                                final String secretKey) {
        return Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token).getBody();
    }

    //check if the token has expired
    public static Boolean isTokenExpired(final String token,
                                         final String secretKey) {
        final var expiration = getExpirationDateFromToken(token, secretKey);
        return expiration.before(new Date());
    }

    //while creating the token -
    //1. Define  claims of the token, like Issuer, Expiration, Subject, and the ID
    //2. Sign the JWT using the HS512 algorithm and secret key.
    //3. According to JWS Compact Serialization(https://tools.ietf.org/html/draft-ietf-jose-json-web-signature-41#section-3.1)
    //   compaction of the JWT to a URL-safe string
    private static String doGenerateToken(final Map<String, Object> claims,
                                          final String subject,
                                          final long expireIn,
                                          final String secretKey) {
        final var today = Date.from(Instant.now());
        final var expiryDate = Date.from(today.toInstant().plus(Duration.ofSeconds(expireIn)));
        return Jwts.builder()
                .setIssuer("core")
                .setClaims(claims)
                .setSubject(subject)
                .setIssuedAt(today)
                .setExpiration(expiryDate)
                .signWith(SignatureAlgorithm.HS512, secretKey).compact();
    }

    public static void parseJWT(String jwt) throws ExpiredJwtException {
        final var tmp = jwt.split("\\.");
        final var jwtWithoutSign = tmp[0] + "." + tmp[1] + ".";
        Jwts.parser().parse(jwtWithoutSign).getBody();
    }

}
